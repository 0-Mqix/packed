// Code generated by github.com/0-mqix/packed; DO NOT EDIT.

package packed

import (
	"github.com/0-mqix/packed"
)

var (
	// packed.Int32
	c0 = &packed.Int32{}
	// packed.Float32
	c1 = &packed.Float32{}
	// packed.StringConverter length: 10
	c2 = &packed.StringConverter{Length: 10}
)

type A struct {
	A int32
	B int32
}

func (reciever *A) Size() int {
	return 8
}

func (reciever *A) ToBytes(bytes []byte, index int) {
	c0.ToBytesLittleEndian(&reciever.A, bytes, index+0)
	c0.ToBytesLittleEndian(&reciever.B, bytes, index+4)
}

func (reciever *A) FromBytes(bytes []byte, index int) {
	c0.FromBytesLittleEndian(&reciever.A, bytes, index+0)
	c0.FromBytesLittleEndian(&reciever.B, bytes, index+4)
}

type B struct {
	A [2][2][2]int32
	B [2]A
	C float32
	D string
}

func (reciever *B) Size() int {
	return 62
}

func (reciever *B) ToBytes(bytes []byte, index int) {
	o0 := index + 0
	for i0 := 0; i0 < 2; i0++ {
		for i1 := 0; i1 < 2; i1++ {
			for i2 := 0; i2 < 2; i2++ {
				c0.ToBytesLittleEndian(&reciever.A[i0][i1][i2], bytes, o0)
				o0 += 4
			}
		}
	}
	o32 := index + 32
	for i0 := 0; i0 < 2; i0++ {
		c0.ToBytesLittleEndian(&reciever.B[i0].A, bytes, o32)
		o32 += 4
		c0.ToBytesLittleEndian(&reciever.B[i0].B, bytes, o32)
		o32 += 4
	}
	c1.ToBytesLittleEndian(&reciever.C, bytes, index+48)
	c2.ToBytesLittleEndian(&reciever.D, bytes, index+52)
}

func (reciever *B) FromBytes(bytes []byte, index int) {
	o0 := index + 0
	for i0 := 0; i0 < 2; i0++ {
		for i1 := 0; i1 < 2; i1++ {
			for i2 := 0; i2 < 2; i2++ {
				c0.FromBytesLittleEndian(&reciever.A[i0][i1][i2], bytes, o0)
				o0 += 4
			}
		}
	}
	o32 := index + 32
	for i0 := 0; i0 < 2; i0++ {
		c0.FromBytesLittleEndian(&reciever.B[i0].A, bytes, o32)
		o32 += 4
		c0.FromBytesLittleEndian(&reciever.B[i0].B, bytes, o32)
		o32 += 4
	}
	c1.FromBytesLittleEndian(&reciever.C, bytes, index+48)
	c2.FromBytesLittleEndian(&reciever.D, bytes, index+52)
}

type C struct {
	A [2][2]B
}

func (reciever *C) Size() int {
	return 248
}

func (reciever *C) ToBytes(bytes []byte, index int) {
	o0 := index + 0
	for i0 := 0; i0 < 2; i0++ {
		for i1 := 0; i1 < 2; i1++ {
			for i2 := 0; i2 < 2; i2++ {
				for i3 := 0; i3 < 2; i3++ {
					for i4 := 0; i4 < 2; i4++ {
						c0.ToBytesLittleEndian(&reciever.A[i0][i1].A[i2][i3][i4], bytes, o0)
						o0 += 4
					}
				}
			}
			for i2 := 0; i2 < 2; i2++ {
				c0.ToBytesLittleEndian(&reciever.A[i0][i1].B[i2].A, bytes, o0)
				o0 += 4
				c0.ToBytesLittleEndian(&reciever.A[i0][i1].B[i2].B, bytes, o0)
				o0 += 4
			}
			c1.ToBytesLittleEndian(&reciever.A[i0][i1].C, bytes, o0)
			o0 += 4
			c2.ToBytesLittleEndian(&reciever.A[i0][i1].D, bytes, o0)
			o0 += 10
		}
	}
}

func (reciever *C) FromBytes(bytes []byte, index int) {
	o0 := index + 0
	for i0 := 0; i0 < 2; i0++ {
		for i1 := 0; i1 < 2; i1++ {
			for i2 := 0; i2 < 2; i2++ {
				for i3 := 0; i3 < 2; i3++ {
					for i4 := 0; i4 < 2; i4++ {
						c0.FromBytesLittleEndian(&reciever.A[i0][i1].A[i2][i3][i4], bytes, o0)
						o0 += 4
					}
				}
			}
			for i2 := 0; i2 < 2; i2++ {
				c0.FromBytesLittleEndian(&reciever.A[i0][i1].B[i2].A, bytes, o0)
				o0 += 4
				c0.FromBytesLittleEndian(&reciever.A[i0][i1].B[i2].B, bytes, o0)
				o0 += 4
			}
			c1.FromBytesLittleEndian(&reciever.A[i0][i1].C, bytes, o0)
			o0 += 4
			c2.FromBytesLittleEndian(&reciever.A[i0][i1].D, bytes, o0)
			o0 += 10
		}
	}
}
