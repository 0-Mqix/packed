package packed

import (
	"bytes"
	"encoding/base64"
	"fmt"
	"os"
	"reflect"

	"golang.org/x/tools/imports"
)

type converterHashField struct {
	reflect reflect.StructField
	hash    bool
	value   any
}

type converterHash struct {
	instance                    any
	reflection                  string
	hasInitializeConverterField bool
	fields                      map[string]converterHashField
	hash                        string
}

var (
	structs                 = map[string]PackedStruct{}
	converters              = map[string]converterHash{}
	imported                = map[string]bool{"github.com/0-mqix/packed": true}
	converterIdentifiers    = map[string]string{}
	converterLastIdentifier = 0
)

type TypeInterface interface {
	Size() int
	ToBytesLittleEndian(bytes []byte, index int)
	FromBytesLittleEndian(bytes []byte, index int)
	ToBytesBigEndian(bytes []byte, index int)
	FromBytesBigEndian(bytes []byte, index int)
}

type ConverterInterface[Reciever any] interface {
	Size() int
	ToBytesLittleEndian(reciever *Reciever, bytes []byte, index int)
	FromBytesLittleEndian(reciever *Reciever, bytes []byte, index int)
	ToBytesBigEndian(reciever *Reciever, bytes []byte, index int)
	FromBytesBigEndian(reciever *Reciever, bytes []byte, index int)
}

type StructInterface interface {
	Size() int
	ToBytes(bytes []byte, index int)
	FromBytes(bytes []byte, index int)
}

type InitializeConverterFieldInterface interface {
	InitializeConverterFields() map[string]string
}

type OverwriteConverterReflectionInterface interface {
	OverwriteConverterReflection(reflection reflect.Type) string
}

type OverwriteConverterReciverReflectionInterface interface {
	OverwriteConverterReciverReflection(reflection reflect.Type) string
}

func createConverterHash(converter any) converterHash {
	reflection := reflect.TypeOf(converter)
	value := reflect.ValueOf(converter)

	if reflection.Kind() == reflect.Ptr {
		reflection = reflection.Elem()
		value = value.Elem()
	}

	hash := reflection.String()

	result := converterHash{instance: converter, reflection: reflection.String(), fields: map[string]converterHashField{}}

	if _, ok := converter.(InitializeConverterFieldInterface); ok {
		result.hasInitializeConverterField = true
	}

	if _, ok := converter.(OverwriteConverterReflectionInterface); ok {
		result.reflection = converter.(OverwriteConverterReflectionInterface).OverwriteConverterReflection(reflection)
	}

	if reflection.Kind() == reflect.Struct {
		for i := 0; i < reflection.NumField(); i++ {
			field := reflection.Field(i)
			fieldValue := value.Field(i)

			if tagValue := field.Tag.Get("packed_hash_field"); tagValue != "" {
				hash += fmt.Sprintf("%s:%v", tagValue, fieldValue.Interface())
				result.fields[tagValue] = converterHashField{reflect: field, value: fieldValue.Interface(), hash: true}
			}
		}
	}

	result.hash = "_" + base64.StdEncoding.WithPadding(base64.NoPadding).EncodeToString([]byte(hash))

	return result
}

func getConverterName(hash string) string {

	if len(hash) > 0 && hash[0] != '_' {
		panic("invalid hash")
	}

	if name, ok := converterIdentifiers[hash]; ok {
		return name
	}

	name := fmt.Sprintf("c%d", converterLastIdentifier)

	converterIdentifiers[hash] = name

	converterLastIdentifier++

	return name
}

func Generate(outputFile string, packageName string) {

	buffer := &bytes.Buffer{}

	fmt.Fprintf(buffer, "// Code generated by github.com/0-mqix/packed; DO NOT EDIT.\n\n")
	fmt.Fprintf(buffer, "package %s\n\n", packageName)
	fmt.Fprintf(buffer, "import (\n")
	for importPath := range imported {
		fmt.Fprintf(buffer, "\"%s\"\n", importPath)
	}
	fmt.Fprintf(buffer, ")\n\n")

	fmt.Fprintf(buffer, "var (\n")

	for _, converter := range converters {

		var initialize InitializeConverterFieldInterface

		if converter.hasInitializeConverterField {
			initialize = converter.instance.(InitializeConverterFieldInterface)
		}

		fmt.Fprintf(buffer, "// %s", converter.reflection)

		for name, field := range converter.fields {

			if !field.hash {
				continue
			}

			fmt.Fprintf(buffer, " %s: %v", name, field.value)
		}

		fmt.Fprintf(buffer, "\n%s = &%s", getConverterName(converter.hash), converter.reflection)

		if converter.hasInitializeConverterField {
			fmt.Fprintf(buffer, "{")

			fields := initialize.InitializeConverterFields()

			for name, value := range fields {
				fmt.Fprintf(buffer, " %s: %v,", name, value)
			}

			fmt.Fprintf(buffer, "}")

		} else {
			fmt.Fprintf(buffer, "{}")
		}

		fmt.Fprintf(buffer, "\n")
	}

	fmt.Fprintf(buffer, ")\n")

	for _, packed := range structs {
		buffer.Write(packed.StructDefinition())
		fmt.Fprintf(buffer, "\n")
		buffer.Write(packed.SizeDefinition())
		fmt.Fprintf(buffer, "\n")
		buffer.Write(packed.ConversionDefinition("ToBytes"))
		fmt.Fprintf(buffer, "\n")
		buffer.Write(packed.ConversionDefinition("FromBytes"))
		fmt.Fprintf(buffer, "\n")
	}

	result, err := imports.Process("", buffer.Bytes(), &imports.Options{
		AllErrors:  true,
		FormatOnly: false,
		Comments:   true,
	})

	if err != nil {
		os.WriteFile("error.go", buffer.Bytes(), 0644)
		fmt.Println(err)
		return
	}

	os.WriteFile(outputFile, result, 0644)
}
